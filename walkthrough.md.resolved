# üîê H∆∞·ªõng D·∫´n Chi Ti·∫øt: Digital Signature Project

T√†i li·ªáu n√†y gi·∫£i th√≠ch chi ti·∫øt c√°ch project ch·ªØ k√Ω s·ªë ho·∫°t ƒë·ªông, ph·ª•c v·ª• √¥n thi v·∫•n ƒë√°p.

---

## üìä T·ªïng Quan Lu·ªìng Ho·∫°t ƒê·ªông

```mermaid
flowchart TB
    subgraph SIGN["üîè QU√Å TR√åNH K√ù"]
        A[üìÑ File g·ªëc] --> B[SHA-256 Hash]
        B --> C[32 bytes hash]
        C --> D[PKCS#1 v1.5 Padding]
        D --> E["RSA Decrypt (v·ªõi Private Key)"]
        E --> F[üîë Ch·ªØ k√Ω s·ªë]
    end
    
    subgraph VERIFY["‚úÖ QU√Å TR√åNH X√ÅC MINH"]
        G[üìÑ File g·ªëc] --> H[SHA-256 Hash]
        H --> I[32 bytes hash]
        J[üîë Ch·ªØ k√Ω s·ªë] --> K["RSA Encrypt (v·ªõi Public Key)"]
        K --> L[PKCS#1 Unpad]
        L --> M[Hash t·ª´ ch·ªØ k√Ω]
        I --> N{So s√°nh}
        M --> N
        N -->|Kh·ªõp| O[‚úÖ H·ª£p l·ªá]
        N -->|Kh√¥ng kh·ªõp| P[‚ùå Kh√¥ng h·ª£p l·ªá]
    end
```

---

## üß± C·∫•u Tr√∫c Project

| File | Ch·ª©c nƒÉng |
|------|-----------|
| [math_utils.py](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py) | GCD, Extended GCD, Mod Inverse, Power Mod |
| [prime_utils.py](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/prime_utils.py) | Miller-Rabin, sinh s·ªë nguy√™n t·ªë |
| [rsa.py](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/crypto/rsa.py) | RSA: sinh key, m√£ h√≥a, gi·∫£i m√£ |
| [sha256.py](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/crypto/sha256.py) | SHA-256 hash |
| [digital_signature.py](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/signature/digital_signature.py) | K√Ω v√† x√°c minh ch·ªØ k√Ω s·ªë |

---

## 1Ô∏è‚É£ math_utils.py - C√°c H√†m To√°n H·ªçc C∆° B·∫£n

### 1.1 GCD - ∆Ø·ªõc Chung L·ªõn Nh·∫•t (Euclid)

```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
```

**Gi·∫£i th√≠ch**: S·ª≠ d·ª•ng thu·∫≠t to√°n Euclid
- Chia `a` cho `b`, l·∫•y s·ªë d∆∞
- L·∫∑p l·∫°i ƒë·∫øn khi s·ªë d∆∞ = 0
- **V√≠ d·ª•**: [gcd(48, 18)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) ‚Üí `48 % 18 = 12` ‚Üí `18 % 12 = 6` ‚Üí `12 % 6 = 0` ‚Üí **GCD = 6**

---

### 1.2 Extended GCD - Euclid M·ªü R·ªông

```python
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    gcd_val, x1, y1 = extended_gcd(b % a, a)
    return gcd_val, y1 - (b // a) * x1, x1
```

**Gi·∫£i th√≠ch**: T√¨m [(g, x, y)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) sao cho `a*x + b*y = g = gcd(a, b)`
- D√πng ƒë·ªá quy ƒë·ªÉ t√≠nh ng∆∞·ª£c l·∫°i
- **D√πng cho**: T√≠nh ngh·ªãch ƒë·∫£o modulo

---

### 1.3 Mod Inverse - Ngh·ªãch ƒê·∫£o Modulo

```python
def mod_inverse(a, m):
    gcd_val, x, _ = extended_gcd(a, m)
    if gcd_val != 1:
        raise ValueError("Ngh·ªãch ƒë·∫£o modulo kh√¥ng t·ªìn t·∫°i")
    return (x % m + m) % m
```

**Gi·∫£i th√≠ch**: T√¨m `x` sao cho [(a * x) % m = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6)
- Ch·ªâ t·ªìn t·∫°i khi [gcd(a, m) = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6)
- **V√≠ d·ª•**: [mod_inverse(3, 7)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#15-20) ‚Üí `x = 5` v√¨ [(3 * 5) % 7 = 15 % 7 = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6)
- **D√πng ƒë·ªÉ**: T√≠nh private key `d` t·ª´ `e` v√† `œÜ(n)` trong RSA

---

### 1.4 Power Mod - L≈©y Th·ª´a Modulo (Square and Multiply)

```python
def power_mod(base, exponent, modulus):
    result = 1
    base = base % modulus
    while exponent > 0:
        if exponent % 2 == 1:       # Bit cu·ªëi = 1
            result = (result * base) % modulus
        exponent = exponent >> 1    # D·ªãch ph·∫£i 1 bit
        base = (base * base) % modulus
    return result
```

**Gi·∫£i th√≠ch**: T√≠nh [(base^exponent) % modulus](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) hi·ªáu qu·∫£
- Kh√¥ng t√≠nh `base^exponent` tr·ª±c ti·∫øp (s·ªë qu√° l·ªõn!)
- D√πng k·ªπ thu·∫≠t **Square and Multiply**:
  - Duy·ªát t·ª´ng bit c·ªßa `exponent` t·ª´ ph·∫£i sang tr√°i
  - N·∫øu bit = 1: `result = result * base`
  - Lu√¥n: `base = base¬≤`

**V√≠ d·ª•**: T√≠nh `3^13 mod 7`
| B∆∞·ªõc | exponent (binary) | base | result |
|------|-------------------|------|--------|
| Ban ƒë·∫ßu | 1101 | 3 | 1 |
| Bit 1 | 110 | 3¬≤=2 | 1√ó3=3 |
| Bit 0 | 11 | 2¬≤=4 | 3 |
| Bit 1 | 1 | 4¬≤=2 | 3√ó4=5 |
| Bit 1 | 0 | 2¬≤=4 | 5√ó2=3 |

K·∫øt qu·∫£: `3^13 mod 7 = 3` ‚úÖ

---

## 2Ô∏è‚É£ prime_utils.py - Sinh S·ªë Nguy√™n T·ªë

### 2.1 Miller-Rabin Primality Test

```python
def miller_rabin(n, k=5):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0: return False
    
    # Vi·∫øt n-1 = 2^r * d
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1
        d //= 2
    
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = power_mod(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = power_mod(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True
```

**Gi·∫£i th√≠ch**: Ki·ªÉm tra s·ªë nguy√™n t·ªë x√°c su·∫•t cao
1. Vi·∫øt `n-1 = 2^r √ó d` (d l·∫ª)
2. V·ªõi m·ªói `a` ng·∫´u nhi√™n trong [2, n-2]:
   - T√≠nh `x = a^d mod n`
   - N·∫øu `x = 1` ho·∫∑c `x = n-1` ‚Üí ti·∫øp t·ª•c
   - B√¨nh ph∆∞∆°ng `x` l√™n `r-1` l·∫ßn, n·∫øu g·∫∑p `n-1` ‚Üí ti·∫øp t·ª•c
   - N·∫øu kh√¥ng ‚Üí s·ªë n√†y l√† **h·ª£p s·ªë**
3. L·∫∑p `k=5` l·∫ßn ‚Üí x√°c su·∫•t sai r·∫•t th·∫•p: `1/4^5 ‚âà 0.1%`

---

### 2.2 Generate Prime

```python
def generate_prime(bits=16):
    while True:
        n = random.getrandbits(bits)
        n |= (1 << (bits - 1)) | 1  # Set bit cao nh·∫•t v√† bit cu·ªëi = 1
        if miller_rabin(n, k=5):
            return n
```

**Gi·∫£i th√≠ch**:
- Sinh s·ªë ng·∫´u nhi√™n `bits` bit
- `|= (1 << (bits-1))` ƒë·∫£m b·∫£o bit cao nh·∫•t = 1 (ƒë·ªß bits)
- `|= 1` ƒë·∫£m b·∫£o s·ªë l·∫ª (s√≥ ch·∫µn kh√¥ng th·ªÉ nguy√™n t·ªë tr·ª´ 2)
- Ki·ªÉm tra Miller-Rabin, n·∫øu pass ‚Üí tr·∫£ v·ªÅ

---

## 3Ô∏è‚É£ rsa.py - Thu·∫≠t To√°n RSA

### 3.1 Sinh C·∫∑p Kh√≥a

```python
def generate_keypair(self, verbose=False):
    # 1. Sinh 2 s·ªë nguy√™n t·ªë p, q
    p = generate_prime(self.key_size // 2)
    q = generate_prime(self.key_size // 2)
    
    # 2. T√≠nh n v√† œÜ(n)
    n = p * q
    phi_n = (p - 1) * (q - 1)
    
    # 3. Ch·ªçn e (th∆∞·ªùng = 65537)
    e = 65537
    if gcd(e, phi_n) != 1:
        e = 3
        while gcd(e, phi_n) != 1:
            e += 2
    
    # 4. T√≠nh d = e^(-1) mod œÜ(n)
    d = mod_inverse(e, phi_n)
    
    self.public_key = (e, n)
    self.private_key = (d, n)
```

**Gi·∫£i th√≠ch chi ti·∫øt**:

| B∆∞·ªõc | C√¥ng th·ª©c | √ù nghƒ©a |
|------|-----------|---------|
| 1 | p, q | 2 s·ªë nguy√™n t·ªë l·ªõn, b√≠ m·∫≠t |
| 2 | n = p √ó q | Modulus, c√¥ng khai |
| 2 | œÜ(n) = (p-1)(q-1) | H√†m Euler, b√≠ m·∫≠t |
| 3 | e = 65537 | Public exponent, [gcd(e, œÜ(n)) = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) |
| 4 | d = e‚Åª¬π mod œÜ(n) | Private exponent, `e√ód ‚â° 1 (mod œÜ(n))` |

> [!IMPORTANT]
> **Public key** = (e, n) - ai c≈©ng bi·∫øt
> **Private key** = (d, n) - ch·ªâ ch·ªß s·ªü h·ªØu bi·∫øt

---

### 3.2 M√£ H√≥a / Gi·∫£i M√£

```python
# M√£ h√≥a: c = m^e mod n
def encrypt(self, plaintext, public_key):
    e, n = public_key
    return power_mod(plaintext, e, n)

# Gi·∫£i m√£: m = c^d mod n
def decrypt(self, ciphertext, private_key):
    d, n = private_key
    return power_mod(ciphertext, d, n)
```

**T·∫°i sao ho·∫°t ƒë·ªông?** Theo ƒë·ªãnh l√Ω Euler:
- `m^(e√ód) ‚â° m^(1 + k√óœÜ(n)) ‚â° m √ó (m^œÜ(n))^k ‚â° m √ó 1^k ‚â° m (mod n)`

---

## 4Ô∏è‚É£ sha256.py - Thu·∫≠t To√°n Hash SHA-256

### 4.1 T·ªïng Quan

SHA-256 bi·∫øn ƒë·∫ßu v√†o b·∫•t k·ª≥ th√†nh chu·ªói 256-bit (32 bytes) c·ªë ƒë·ªãnh.

```mermaid
flowchart LR
    A[Message] --> B[Padding]
    B --> C["Chia th√†nh chunks 512-bit"]
    C --> D["X·ª≠ l√Ω t·ª´ng chunk (64 rounds)"]
    D --> E["N·ªëi 8 gi√° tr·ªã H (256-bit)"]
    E --> F[Hash Output]
```

---

### 4.2 C√°c H·∫±ng S·ªë

```python
# 8 gi√° tr·ªã kh·ªüi t·∫°o H (cƒÉn b·∫≠c 2 c·ªßa 8 s·ªë nguy√™n t·ªë ƒë·∫ßu ti√™n)
self.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
          0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]

# 64 h·∫±ng s·ªë K (cƒÉn b·∫≠c 3 c·ªßa 64 s·ªë nguy√™n t·ªë ƒë·∫ßu ti√™n)
self.k = [0x428a2f98, 0x71374491, ...]  # 64 gi√° tr·ªã
```

---

### 4.3 Padding

```python
def padding(self, message):
    msg_len = len(message)
    message += b'\x80'               # Th√™m bit '1'
    while len(message) % 64 != 56:   # Th√™m '0' ƒë·∫øn khi = 56 mod 64
        message += b'\x00'
    message += struct.pack('>Q', msg_len * 8)  # Th√™m ƒë·ªô d√†i g·ªëc (64-bit)
    return message
```

**V√≠ d·ª•**: Message "abc" (3 bytes)
```
61 62 63 | 80 00 00 00 ... 00 | 00 00 00 00 00 00 00 18
   abc   |  padding (52 bytes) |  length = 24 bits
```

---

### 4.4 Process Chunk (64 Rounds)

```python
def process_chunk(self, chunk):
    # Chia chunk 512-bit th√†nh 16 t·ª´ 32-bit
    w = list(struct.unpack('>16I', chunk))
    
    # M·ªü r·ªông th√†nh 64 t·ª´
    for i in range(16, 64):
        s0 = right_rotate(w[i-15], 7) ^ right_rotate(w[i-15], 18) ^ (w[i-15] >> 3)
        s1 = right_rotate(w[i-2], 17) ^ right_rotate(w[i-2], 19) ^ (w[i-2] >> 10)
        w.append((w[i-16] + s0 + w[i-7] + s1) & 0xFFFFFFFF)
    
    # 64 rounds compression
    a, b, c, d, e, f, g, h = self.h
    for i in range(64):
        S1 = right_rotate(e, 6) ^ right_rotate(e, 11) ^ right_rotate(e, 25)
        ch = (e & f) ^ (~e & g)
        temp1 = (h + S1 + ch + self.k[i] + w[i]) & 0xFFFFFFFF
        
        S0 = right_rotate(a, 2) ^ right_rotate(a, 13) ^ right_rotate(a, 22)
        maj = (a & b) ^ (a & c) ^ (b & c)
        temp2 = (S0 + maj) & 0xFFFFFFFF
        
        h, g, f, e = g, f, e, (d + temp1) & 0xFFFFFFFF
        d, c, b, a = c, b, a, (temp1 + temp2) & 0xFFFFFFFF
    
    # C·ªông v√†o H
    self.h = [(x + y) & 0xFFFFFFFF for x, y in zip(self.h, [a,b,c,d,e,f,g,h])]
```

**C√°c ph√©p to√°n trong m·ªói round**:
- **Œ£0, Œ£1**: Xoay ph·∫£i v√† XOR
- **Ch (Choose)**: [(e AND f) XOR (NOT e AND g)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) - d·ª±a v√†o e ch·ªçn f ho·∫∑c g
- **Maj (Majority)**: [(a AND b) XOR (a AND c) XOR (b AND c)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) - bit n√†o chi·∫øm ƒëa s·ªë

---

## 5Ô∏è‚É£ digital_signature.py - K√Ω S·ªë

### 5.1 PKCS#1 v1.5 Padding

```python
SHA256_DIGEST_INFO = bytes([
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09,
    0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,
    0x05, 0x00, 0x04, 0x20
])

def pkcs1_pad(self, hash_bytes: bytes, key_size_bytes: int) -> int:
    digest_info = SHA256_DIGEST_INFO + hash_bytes
    ps_len = key_size_bytes - 3 - len(digest_info)
    em = b'\x00\x01' + (b'\xff' * ps_len) + b'\x00' + digest_info
    return int.from_bytes(em, 'big')
```

**C·∫•u tr√∫c PKCS#1 v1.5 padded message**:
```
00 01 | FF FF FF ... FF | 00 | DigestInfo + Hash
 2B   |   padding (‚â•8B) | 1B |     51 bytes
```

> [!NOTE]
> **DigestInfo** = ASN.1 header (19 bytes) + SHA-256 Hash (32 bytes) = 51 bytes

---

### 5.2 Quy Tr√¨nh K√Ω

```python
def sign(self, message, private_key):
    d, n = private_key
    key_size_bytes = (n.bit_length() + 7) // 8
    
    # 1. Hash message
    hash_hex = self.sha256.hash(message)
    hash_bytes = bytes.fromhex(hash_hex)
    
    # 2. PKCS#1 v1.5 padding
    padded_message = self.pkcs1_pad(hash_bytes, key_size_bytes)
    
    # 3. RSA "decrypt" v·ªõi private key ‚Üí ch·ªØ k√Ω
    return self.rsa.decrypt(padded_message, private_key)
```

**Lu·ªìng**: `message ‚Üí SHA-256 ‚Üí PKCS#1 pad ‚Üí RSA decrypt (v·ªõi d) ‚Üí signature`

> [!IMPORTANT]
> K√Ω d√πng **decrypt** (v·ªõi private key d), kh√¥ng ph·∫£i encrypt!
> C√¥ng th·ª©c: `signature = padded_hash^d mod n`

---

### 5.3 Quy Tr√¨nh X√°c Minh

```python
def verify(self, message, signature, public_key):
    e, n = public_key
    key_size_bytes = (n.bit_length() + 7) // 8
    
    # 1. RSA "encrypt" ch·ªØ k√Ω v·ªõi public key
    decrypted = self.rsa.encrypt(signature, public_key)
    
    # 2. G·ª° padding, l·∫•y hash
    extracted_hash = self.pkcs1_unpad(decrypted, key_size_bytes)
    
    # 3. Hash message g·ªëc
    hash_hex = self.sha256.hash(message)
    
    # 4. So s√°nh
    return extracted_hash == bytes.fromhex(hash_hex)
```

**Lu·ªìng**: 
```
signature ‚Üí RSA encrypt (v·ªõi e) ‚Üí unpad ‚Üí hash_from_sig
message ‚Üí SHA-256 ‚Üí hash_of_message
So s√°nh: hash_from_sig == hash_of_message?
```

---

## üéØ C√¢u H·ªèi V·∫•n ƒê√°p Th∆∞·ªùng G·∫∑p

### Q1: T·∫°i sao c·∫ßn hash tr∆∞·ªõc khi k√Ω?
**A**: V√¨ RSA ch·ªâ m√£ h√≥a ƒë∆∞·ª£c s·ªë `m < n`. Hash 256-bit nh·ªè h∆°n nhi·ªÅu so v·ªõi key 512+ bit.

### Q2: T·∫°i sao k√Ω d√πng decrypt, x√°c minh d√πng encrypt?
**A**: To√°n h·ªçc RSA ƒë·ªëi x·ª©ng: [(m^d)^e = (m^e)^d = m (mod n)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6)
- **K√Ω**: Ch·ªâ ng∆∞·ªùi c√≥ `d` m·ªõi t·∫°o ƒë∆∞·ª£c `sig = m^d`
- **X√°c minh**: Ai c√≥ `e` c≈©ng ki·ªÉm tra ƒë∆∞·ª£c `sig^e = m`

### Q3: PKCS#1 v1.5 d√πng ƒë·ªÉ l√†m g√¨?
**A**: 
- Th√™m c·∫•u tr√∫c c·ªë ƒë·ªãnh ƒë·ªÉ ch·ªëng t·∫•n c√¥ng
- Ch·ª©a OID (Object Identifier) cho SHA-256
- ƒê·∫£m b·∫£o hash ƒë√∫ng 32 bytes

### Q4: Miller-Rabin c√≥ ch√≠nh x√°c 100% kh√¥ng?
**A**: Kh√¥ng, nh∆∞ng x√°c su·∫•t sai c·ª±c th·∫•p. V·ªõi k=5 rounds, x√°c su·∫•t s·ªë h·ª£p pass l√† `~1/4^5 = 0.1%`.

### Q5: T·∫°i sao e = 65537?
**A**: 
- L√† s·ªë nguy√™n t·ªë Fermat: `65537 = 2^16 + 1`
- D·∫°ng binary: `10000000000000001` (ch·ªâ 2 bit 1) ‚Üí encrypt nhanh
- ƒê·ªß l·ªõn ƒë·ªÉ an to√†n

### Q6: L√†m sao ch·ªëng gi·∫£ m·∫°o ch·ªØ k√Ω?
**A**: Kh√¥ng th·ªÉ t√≠nh `d` t·ª´ [(e, n)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) v√¨ c·∫ßn ph√¢n t√≠ch `n = p √ó q` (r·∫•t kh√≥ v·ªõi n l·ªõn).

---

## üìù T·ªïng K·∫øt C√¥ng Th·ª©c

| Th√†nh ph·∫ßn | C√¥ng th·ª©c |
|------------|-----------|
| Sinh key | n = p√óq, œÜ(n) = (p-1)(q-1), d = e‚Åª¬π mod œÜ(n) |
| K√Ω | sig = (PKCS1_pad(SHA256(m)))^d mod n |
| X√°c minh | SHA256(m) == PKCS1_unpad(sig^e mod n) |

Ch√∫c b·∫°n thi t·ªët! üéì

---

# üìò PH·∫¶N B·ªî SUNG: Chi Ti·∫øt math_utils & prime_utils

> [!IMPORTANT]
> Ph·∫ßn n√†y d√†nh ri√™ng cho b·∫°n - ng∆∞·ªùi ph·ª• tr√°ch **math_utils** v√† **prime_utils**

---

## üî¢ PH·∫¶N A: math_utils.py Chi Ti·∫øt

### A1. GCD - Thu·∫≠t to√°n Euclid

**Nguy√™n l√Ω**: [gcd(a, b) = gcd(b, a mod b)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) cho ƒë·∫øn khi `b = 0`

**V√≠ d·ª• ch·∫°y tay**: T√¨m [gcd(252, 105)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6)

| B∆∞·ªõc | a | b | a mod b |
|------|---|---|---------|
| 1 | 252 | 105 | 252 % 105 = 42 |
| 2 | 105 | 42 | 105 % 42 = 21 |
| 3 | 42 | 21 | 42 % 21 = 0 |
| 4 | 21 | **0** | D·ª™NG |

**K·∫øt qu·∫£**: [gcd(252, 105) = 21](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) ‚úÖ

---

### A2. Extended GCD - Euclid M·ªü R·ªông

**M·ª•c ti√™u**: T√¨m [(g, x, y)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) sao cho `ax + by = g = gcd(a, b)`

**V√≠ d·ª• ch·∫°y tay**: T√¨m `x, y` sao cho `35x + 15y = gcd(35, 15)`

**B∆∞·ªõc 1: T√≠nh GCD (ƒëi xu·ªëng)**
```
35 = 15 √ó 2 + 5
15 = 5 √ó 3 + 0
‚Üí gcd = 5
```

**B∆∞·ªõc 2: Thay ng∆∞·ª£c l·∫°i (ƒëi l√™n)**
```
5 = 35 - 15 √ó 2
5 = 35 √ó 1 + 15 √ó (-2)
```

**K·∫øt qu·∫£**: `x = 1, y = -2` ‚Üí `35(1) + 15(-2) = 35 - 30 = 5` ‚úÖ

**Code trace**:
```python
extended_gcd(35, 15)
    extended_gcd(15, 5)  # 35 % 15 = 5
        extended_gcd(5, 0)   # 15 % 5 = 0
            return (5, 0, 1)  # Base case: a=0
        # gcd=5, x1=0, y1=1
        return (5, 1 - (15//5)*0, 0) = (5, 1, 0)
    # gcd=5, x1=1, y1=0
    return (5, 0 - (35//15)*1, 1) = (5, -2, 1)
# ƒê·ªïi v·ªã tr√≠: a=35, b=15 ‚Üí x=1, y=-2
```

---

### A3. Mod Inverse - Ngh·ªãch ƒê·∫£o Modulo

**ƒê·ªãnh nghƒ©a**: T√¨m `x` sao cho [(a √ó x) mod m = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6)

**ƒêi·ªÅu ki·ªán t·ªìn t·∫°i**: [gcd(a, m) = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6)

**V√≠ d·ª• 1**: T√¨m [mod_inverse(3, 11)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#15-20)
```
3 √ó x ‚â° 1 (mod 11)
```

Th·ª≠: `3√ó1=3, 3√ó2=6, 3√ó3=9, 3√ó4=12‚â°1 (mod 11)` ‚Üí **x = 4** ‚úÖ

**V√≠ d·ª• 2**: T√¨m [mod_inverse(7, 26)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#15-20) (d√πng trong m√£ h√≥a)

D√πng Extended GCD:
```
extended_gcd(7, 26):
  26 = 7 √ó 3 + 5
  7 = 5 √ó 1 + 2
  5 = 2 √ó 2 + 1
  2 = 1 √ó 2 + 0 ‚Üí gcd = 1

Thay ng∆∞·ª£c:
  1 = 5 - 2√ó2
  1 = 5 - (7-5)√ó2 = 5√ó3 - 7√ó2
  1 = (26-7√ó3)√ó3 - 7√ó2 = 26√ó3 - 7√ó11

‚Üí 7 √ó (-11) ‚â° 1 (mod 26)
‚Üí -11 mod 26 = 15
```

**K·∫øt qu·∫£**: [mod_inverse(7, 26) = 15](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#15-20) ‚úÖ

Ki·ªÉm tra: `7 √ó 15 = 105 = 26√ó4 + 1` ‚Üí ƒë√∫ng!

---

### A4. Power Mod - Square and Multiply

**V·∫•n ƒë·ªÅ**: T√≠nh `base^exp mod m` v·ªõi `exp` r·∫•t l·ªõn

**Naive approach** (kh√¥ng d√πng):
```python
result = (base ** exp) % m  # SAI! base^exp qu√° l·ªõn
```

**Square and Multiply** (d√πng trong code):
- Bi·ªÉu di·ªÖn `exp` d·∫°ng binary
- Duy·ªát t·ª´ bit th·∫•p ƒë·∫øn cao
- N·∫øu bit = 1: nh√¢n result v·ªõi base
- Lu√¥n lu√¥n: b√¨nh ph∆∞∆°ng base

**V√≠ d·ª• chi ti·∫øt**: T√≠nh `3^13 mod 7`

`13` trong binary = `1101`

| B∆∞·ªõc | exp (dec) | exp (bin) | Bit cu·ªëi | Action | base | result |
|------|-----------|-----------|----------|--------|------|--------|
| Init | 13 | 1101 | - | - | 3 | 1 |
| 1 | 13 | 1101 | **1** | result = result √ó base | 3 | 1√ó3 = 3 |
| 1' | 6 | 110 | - | base = base¬≤ | 3¬≤=9%7=2 | 3 |
| 2 | 6 | 110 | **0** | (skip) | 2 | 3 |
| 2' | 3 | 11 | - | base = base¬≤ | 2¬≤=4 | 3 |
| 3 | 3 | 11 | **1** | result = result √ó base | 4 | 3√ó4=12%7=5 |
| 3' | 1 | 1 | - | base = base¬≤ | 4¬≤=16%7=2 | 5 |
| 4 | 1 | 1 | **1** | result = result √ó base | 2 | 5√ó2=10%7=3 |
| 4' | 0 | 0 | - | D·ª™NG | - | **3** |

**K·∫øt qu·∫£**: `3^13 mod 7 = 3` ‚úÖ

**ƒê·ªô ph·ª©c t·∫°p**: O(log exp) thay v√¨ O(exp)

---

## üîê PH·∫¶N B: prime_utils.py Chi Ti·∫øt

### B1. Miller-Rabin Primality Test

**C∆° s·ªü to√°n h·ªçc**: ƒê·ªãnh l√Ω Fermat nh·ªè
- N·∫øu `p` nguy√™n t·ªë v√† [gcd(a, p) = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) th√¨ `a^(p-1) ‚â° 1 (mod p)`

**√ù t∆∞·ªüng Miller-Rabin**:
1. Vi·∫øt `n-1 = 2^r √ó d` (v·ªõi d l·∫ª)
2. Ki·ªÉm tra: `a^d ‚â° 1 (mod n)` ho·∫∑c `a^(d√ó2^i) ‚â° -1 (mod n)` v·ªõi i ‚àà [0, r-1]
3. N·∫øu kh√¥ng th·ªèa ‚Üí ch·∫Øc ch·∫Øn h·ª£p s·ªë
4. N·∫øu th·ªèa ‚Üí c√≥ th·ªÉ nguy√™n t·ªë

**V√≠ d·ª• 1**: Ki·ªÉm tra n = 221 c√≥ ph·∫£i nguy√™n t·ªë?

```
n - 1 = 220 = 4 √ó 55 = 2¬≤ √ó 55
‚Üí r = 2, d = 55
```

Ch·ªçn a = 174:
```python
x = power_mod(174, 55, 221) = 47
# 47 ‚â† 1 v√† 47 ‚â† 220 (n-1)

x = power_mod(47, 2, 221) = 220  # = n-1 ‚úì
# V√≤ng n√†y pass
```

Ch·ªçn a = 137:
```python
x = power_mod(137, 55, 221) = 188
# 188 ‚â† 1 v√† 188 ‚â† 220

x = power_mod(188, 2, 221) = 205  # ‚â† 220
# Kh√¥ng t√¨m th·∫•y n-1 ‚Üí 221 l√† H·ª¢P S·ªê!
```

Th·ª±c t·∫ø: `221 = 13 √ó 17` ‚úÖ

**V√≠ d·ª• 2**: Ki·ªÉm tra n = 17 (nguy√™n t·ªë)

```
n - 1 = 16 = 2^4 √ó 1
‚Üí r = 4, d = 1
```

Ch·ªçn a = 3:
```python
x = power_mod(3, 1, 17) = 3
# 3 ‚â† 1 v√† 3 ‚â† 16

x = power_mod(3, 2, 17) = 9   # ‚â† 16
x = power_mod(9, 2, 17) = 13  # ‚â† 16
x = power_mod(13, 2, 17) = 16 # = n-1 ‚úì PASS!
```

‚Üí 17 c√≥ th·ªÉ l√† nguy√™n t·ªë (ƒë√∫ng!) ‚úÖ

---

### B2. T·∫°i sao Miller-Rabin ch·ª© kh√¥ng ph·∫£i brute-force?

| Ph∆∞∆°ng ph√°p | ƒê·ªô ph·ª©c t·∫°p | V·ªõi n = 10^100 |
|-------------|-------------|----------------|
| Brute-force (chia th·ª≠) | O(‚àön) | 10^50 ph√©p t√≠nh |
| Miller-Rabin (k=5) | O(k √ó log¬≥n) | ~500,000 ph√©p t√≠nh |

---

### B3. Generate Prime - Sinh S·ªë Nguy√™n T·ªë

```python
def generate_prime(bits=16):
    while True:
        n = random.getrandbits(bits)
        n |= (1 << (bits - 1)) | 1  # ƒê·∫£m b·∫£o ƒë·ªß bits v√† l·∫ª
        if miller_rabin(n, k=5):
            return n
```

**Gi·∫£i th√≠ch bit manipulation**:

`n |= (1 << (bits - 1)) | 1` l√†m 2 vi·ªác:

1. [(1 << (bits - 1))](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) = set bit cao nh·∫•t = 1
   - V√≠ d·ª•: bits=8 ‚Üí `1 << 7 = 10000000`
   - ƒê·∫£m b·∫£o s·ªë c√≥ **ƒë√∫ng** 8 bit, kh√¥ng ph·∫£i 7 bit

2. `| 1` = set bit th·∫•p nh·∫•t = 1
   - ƒê·∫£m b·∫£o s·ªë **l·∫ª** (s·ªë ch·∫µn kh√¥ng th·ªÉ nguy√™n t·ªë, tr·ª´ 2)

**V√≠ d·ª•**:
```python
bits = 8
n = random.getrandbits(8)  # Gi·∫£ s·ª≠ n = 01010110 (=86)
n |= (1 << 7) | 1          # n = 11010111 (=215)
# B√¢y gi·ªù n ‚àà [128, 255] v√† l·∫ª
```

---

### B4. X√°c su·∫•t sai c·ªßa Miller-Rabin

V·ªõi m·ªói l·∫ßn test (1 gi√° tr·ªã a):
- X√°c su·∫•t s·ªë h·ª£p "l·ªçt" qua ‚â§ 1/4

V·ªõi k = 5 l·∫ßn test:
- X√°c su·∫•t sai ‚â§ (1/4)^5 = 1/1024 ‚âà **0.1%**

V·ªõi k = 10:
- X√°c su·∫•t sai ‚â§ (1/4)^10 ‚âà **0.0001%**

---

## üß© PH·∫¶N C: K·∫øt N·ªëi C√°c Module

### Lu·ªìng t·ª´ math ‚Üí prime ‚Üí RSA ‚Üí Signature

```mermaid
flowchart TB
    subgraph MATH["math_utils.py"]
        A1[gcd] --> A2[extended_gcd]
        A2 --> A3[mod_inverse]
        A4[power_mod]
    end
    
    subgraph PRIME["prime_utils.py"]
        A4 --> B1[miller_rabin]
        B1 --> B2[generate_prime]
    end
    
    subgraph RSA["rsa.py"]
        B2 --> C1["Sinh p, q"]
        C1 --> C2["n = p √ó q"]
        C2 --> C3["œÜ(n) = (p-1)(q-1)"]
        A3 --> C4["d = e‚Åª¬π mod œÜ(n)"]
        A4 --> C5["encrypt/decrypt"]
    end
    
    subgraph SIG["digital_signature.py"]
        D1[SHA-256] --> D2[PKCS#1 pad]
        D2 --> C5
        C5 --> D3[Ch·ªØ k√Ω]
    end
```

### B·∫£ng s·ª≠ d·ª•ng h√†m

| H√†m math_utils | D√πng ·ªü ƒë√¢u | M·ª•c ƒë√≠ch |
|----------------|------------|----------|
| [gcd(a, b)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) | RSA.generate_keypair | Ki·ªÉm tra [gcd(e, œÜ(n)) = 1](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#2-6) |
| [mod_inverse(a, m)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#15-20) | RSA.generate_keypair | T√≠nh `d = e‚Åª¬π mod œÜ(n)` |
| [power_mod(b, e, m)](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#22-33) | miller_rabin, RSA.encrypt, RSA.decrypt | T√≠nh `a^d mod n`, `m^e mod n` |

---

## ‚ùì C√¢u H·ªèi V·∫•n ƒê√°p B·ªï Sung (D√†nh cho ph·∫ßn Math/Prime)

### Q7: Extended GCD kh√°c GCD th∆∞·ªùng nh∆∞ th·∫ø n√†o?
**A**: 
- GCD ch·ªâ tr·∫£ v·ªÅ **∆∞·ªõc chung l·ªõn nh·∫•t** g
- Extended GCD tr·∫£ v·ªÅ th√™m **x, y** sao cho `ax + by = g`
- Extended GCD c·∫ßn thi·∫øt ƒë·ªÉ t√≠nh **ngh·ªãch ƒë·∫£o modulo**

### Q8: T·∫°i sao c·∫ßn ngh·ªãch ƒë·∫£o modulo trong RSA?
**A**: ƒê·ªÉ t√≠nh private key `d`:
- Ta c√≥ `e √ó d ‚â° 1 (mod œÜ(n))`
- T·ª©c l√† `d = e‚Åª¬π mod œÜ(n)` = [mod_inverse(e, œÜ(n))](file:///c:/Users/Admin/OneDrive/Desktop/digital-signature/backend/utils/math_utils.py#15-20)

### Q9: Square and Multiply ti·∫øt ki·ªám bao nhi√™u?
**A**: V√≠ d·ª• t√≠nh `a^1000000`:
- Naive: 1,000,000 ph√©p nh√¢n
- Square & Multiply: log‚ÇÇ(1,000,000) ‚âà **20 ph√©p t√≠nh**
- Ti·∫øt ki·ªám 50,000 l·∫ßn!

### Q10: Miller-Rabin fail khi n√†o?
**A**: V·ªõi **s·ªë Carmichael** (nh∆∞ 561 = 3√ó11√ó17), c·∫ßn nhi·ªÅu witness ƒë·ªÉ ph√°t hi·ªán. Nh∆∞ng v·ªõi k‚â•5, x√°c su·∫•t r·∫•t th·∫•p.

### Q11: T·∫°i sao set bit cao nh·∫•t khi sinh prime?
**A**: ƒê·∫£m b·∫£o s·ªë c√≥ **ƒë√∫ng N bit**. V√≠ d·ª• sinh 512-bit prime:
- Kh√¥ng set: c√≥ th·ªÉ ra 400-bit number
- Set bit 511: ƒë·∫£m b·∫£o 512 bit

### Q12: C√≥ th·ªÉ d√πng thu·∫≠t to√°n kh√°c thay Miller-Rabin?
**A**: C√≥:
- **AKS**: Deterministic, O(log^6 n), ch·∫≠m h∆°n
- **Fermat test**: Nhanh nh∆∞ng b·ªã l·ª´a b·ªüi Carmichael numbers
- **Solovay-Strassen**: T∆∞∆°ng t·ª± Miller-Rabin, √≠t d√πng h∆°n
